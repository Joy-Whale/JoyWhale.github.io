---
title: 安卓apk廋身的一些经验
date: 2017-02-21 10:04:30
categories:
- 技术
- Android
tags: 
- Android
- Android apk廋身
---
## 正文
由于公司app老版本使用的框架无法满足现有的需求，并且臃肿无比，去年后半年开始，app实施重构。虽是重构，但由于需要与新的需求并行，后来决定采取部分重构的方法来兼容老代码维护以及新代码重构，即在有新需求时将所涉及到的模块以新的框架实现，再与老代码实现适配，在此过程中，apk瘦身是必不可少的，几个版本下来，apk体积已从30M左右减少到现在的24M左右。

### 瘦身的好处
即是部分重构，就涉及到了新老代码共存的情况，我们完全可以遗留旧代码、旧资源然后打包apk，省时省力，何乐而不为。但从长远角度来看，这只能使项目越做越糟糕，首先旧的代码与新的代码混合，越往后越理不清，越理不清越是不敢乱动，维护成本几何上升，apk体积也越来越大，下载转化率也会越来越低。试想你的app有30M，但市场中同类app体积只有10多M，大部分用户会下载体积小的app。安装包越小，用户下载等待的时间越短，对手机存储配置小的设备体验愈佳，应用的下载转化率也就越高。

### 瘦身的方法
说完瘦身的好处，下面说下我在项目重构过程中总结的瘦身经验，剃去老代码以及老资源只是其中的一部分。首先我们需要分析下apk的体积情况，从Android Studio 2.2.3 开始，就加入了浏览 APK 结构的功能，只需要将apk拖到Android Studio内，即可直接显示出apk的结构以及对应的大小，这样就能边分析边做优化。

![image](http://ol58plgkm.bkt.clouddn.com/LJOF_WV0R1W8HFHBFM70UA4.png)

我们来分析apk每个部分及它所对应的作用：
- lib                  存放应用的native库文件，即jni文件
- res                  存放应用的资源文件
- classes.dex          应用中java代码编译完成后最终都会转化为dex文件
- assets               存放应用的原始文件
- resources.arsc       存放应用的所有资源文件的id的映射
- META-INF             存放应用的签名校验相关的文件
- AndroidManifest.xml  应用的全局配置文件
- 其他                 应用的其他配置生成的一些文件

结合图中各部分的大小，可以看出安装包中占比较大的为：lib文件夹、res文件夹、dex包、assets包，resources.arsc竟然也占有1M多的内存。

下面针对这几个占比大头来说下我的优化经验：
#### lib 
lib中存放有应用的native库文件，即jni文件

![image](http://ol58plgkm.bkt.clouddn.com/S3K%25C$QE45P%28F3%29HV9MAV9R.png)

如图所示，lib下有x86、x86_64、arm64-v8a、armeabi-v7a、armeabi这几个文件夹，分别存放有一个.so库所对应的不同CPU架构的兼容文件，这也是lib文件夹体积大的原因，当我们应用中的native库文件增多时，并且在x86、x86_64、arm64-v8a、armeabi-v7a、armeabi这几个文件夹下面都添加了对应的.so文件，那么lib文件体积将乘几倍的提升。

当我们的应用不需要支持这么多CPU架构的机型时，或是对native库的性能及兼容性并没有那么重视的话，可以将其中几个CPU架构所对应的.so库文件夹删除，通常的，只保留armeabi、armeabi-v7a、x86几个满足绝大多数手机的需求，再甚者，只留armeabi即可，因为所有的x86/x86_64/armeabi-v7a/arm64-v8a设备都支持armeabi架构的.so文件，当然，这必须视情况而定，例如x86设备能够很好的运行ARM类型函数库，但并不保证100%不发生crash，特别是对旧设备。64位设备（arm64-v8a, x86_64, mips64）能够运行32位的函数库，但是以32位模式运行，在64位平台上运行32位版本的ART和Android组件，将丢失专为64位优化过的性能（ART，webview，media等等）。

若不想删除这些.so文件，还有另外一种更好的方法来处理这个问题：
```
// 设置支持的SO库架构
    ndk {
        abiFilters 'armeabi', 'armeabi-v7a','x86'
        //, 'x86_64', 'arm64-v8a','arm64-v8a'
    }
```
在项目build.gradle的defaultConfig中添加上面这段代码来指定应用支持的so库框架，这样当我们打包时，android studio会根据我们的设定，只将指定的so文件打入到apk中。

#### res
res文件夹中存放有应用的所有资源文件。怎样减小res文件夹体积一直是个老生常谈的问题。
- 删除不必要的drawable文件夹 
首先说下前几年开发过程中我们是如何处理res资源文件的，为了做是适配，我们将不同分辨率的图片存放到了drawable-mdpi、drawable-ldpi、drawable-hdpi、drawable-xhdpi文件夹下，其实这是完全没必要的，我所做的项目中，仅仅在drawable-xxhdpi文件夹中存放了一份像素大的资源文件，其实这完全可以适配绝大多数手机，当然这取决于你在layout.xml中的适配是否做的足够好，如果在layout中添加一个ImageView，只要将ImageView的width、height以及scaleType都处理好，那么图片显示效果是不会有什么差异的。

- 使用Drawable XML、Color、.9 PNG代替PNG
一些情况下，我们可以考虑使用Drawable XML来代替 PNG，如渐变的背景图、圆角纯色或带边框图片、圆形的纯色或带边框图片、List Item之间的纯色或带边框的填充图片等，用几行XML及可描绘出来
用Color代替PNG，如：纯色的背景
用.9 PNG代替PNG

- 使用JPG代替PNG
用JPG代替PNG，由于JPG没有Alpha通道，所以文件更小，适用于不需要透明度的图片可以考虑，当然还可以再做进一步的压缩等(在线压缩图片网站比比皆是，就不做介绍了)，通常一个几百k甚至1M的PNG图片转化为JPG文件并做压缩，结果仅仅只有十几到几十K左右，并且显示效果并没有什么差别。

- 使用VectorDrawable代替PNG
VectorDrawable是Android在5.0之后提供的一种图片适配的新功能，它可以使用SVG类型资源来代替PNG图片，Vector Drawable相对于普通的Drawable来说，有以下几个好处：Vector图像可以自动进行适配，不需要通过分辨率来设置不同的图片；Vector图像可以大幅减少图像的体积，同样一张图，用Vector来实现，可能只有PNG的几十分之一；使用简单，很多设计工具，都可以直接导出SVG图像，从而转换成Vector图像；功能强大，不用写很多代码就可以实现非常复杂的动画；成熟、稳定，前端已经非常广泛的进行使用了。

Vector图像刚发布的时候，是只支持Android 5.0+的，对于Android pre-L的系统来说，并不能使用，所以，可以说那时候的Vector并没有什么卵用。不过自从AppCompat 23.2之后，Google对p-View的Android系统也进行了兼容，也就是说，Vector可以使用于Android 2.1以上的所有系统，只需要引用com.android.support:appcompat-v7:23.2.0以上的版本就可以了，这时候，Vector应该算是迎来了它的春天。

Vector Magic Desktop Edition是一款可以将PNG图片转换为SVG文件的软件，使用起来也非常方便：

软件截图
![image](http://ol58plgkm.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720170221121646.png)

首先将PNG图片拖到Vector Magic中，点击右上角的Fully Automatic按钮即可生成SVG预览图
![image](http://ol58plgkm.bkt.clouddn.com/2.png)

点击右上角Done Reviewing按钮跳转到保存页面
![image](http://ol58plgkm.bkt.clouddn.com/4.png)

点击右上角Save as按钮将SVG文件保存到本地
![image](http://ol58plgkm.bkt.clouddn.com/5.png)

当SVG图生成后，我们需要将其转换为我们需要的Vector Drawable。
[点击这里](http://inloop.github.io/svg2android/)是一个在线SVG转换Vector Drawable的网站，我们只需将上一步生成的SVG文件拖入到网页中，即可将SVG文件转换为Vector Drawable代码
![image](http://ol58plgkm.bkt.clouddn.com/2%60$I3N%7BA~%600JT6TP@A6~NCQ.png)
这时，我们需要做的就是将这些代码下载或拷贝下来然后放入我们的drawable文件夹下即可直接调用。

#### classes.dex
classes.dex是应用中java代码编译完成后最终转化生成的文件，它包含我们自己开发的文件以及引入的第三方jar包和module等。这里可以做的事情也是很多：
- 移除废弃功能的代码
- 移除重复的代码
- 移除功能重叠的框架  如Volley、AsyncHttpClient、Retrofit等，或是同一个框架有不同的版本，可以将老的版本替换掉。
- 移除无用的dependencies或者jar包
- 减小对 upport兼容包的依赖  support-v4包体积非常大，引入项目无疑会增大dex文件的大小，Google已意识到该问题，所以support-v7一开始就做了拆包处理，并且从support 24.1.0开始对support-v4做拆分，所以我们项目中尽量只引用需要用到的support包即可，切不可一股脑都添加到项目依赖中。

#### assets
assets文件夹和res文件夹下的raw文件夹都是用来存放应用中所用到的其他文件的，像应用中使用到的字体、音乐、视频等。这方面要做的就只有尽量减小资源文件大小了。
- 有损编码格式的音频文件代替无损格式的音频文件
    Android 平台支持的音视频格式，下面列出有损和无损常用的格式（不要认为有损编码就是音质很差）：
        无损格式：WAV，PCM，ALS，ALAC，TAK，FLAC，APE，WavPack(WV)
        有损格式：MP3，AAC，WMA，Ogg Vorbis
实际开发中需要使用音频文件尽量采用 MP3、Ogg 这种有损格式，尽量不要用 WAV、PCM 这种无损音频。
- 压缩字体资源包
有的字体资源只是用来显示英文或数字，这时候就不需要完整的字体资源包，删除其中无用的字体是非常有必要的。
- 将资源文件放到线上下载
有些资源文件不是必须要用到的，可以先放到服务器上，然后在启动应用后再下载到本地使用。

#### resources.arsc
resources.arsc中存放应用的所有资源文件的id的映射，有且只有减少无用的资源文件id才能使resources.arsc文件体积减小。可以将过时的layout文件、string、style等。

## 总结
上述这些方法都是我在实际开发过程中总结的一些经验，具体操作还是需要根据项目情况而定。